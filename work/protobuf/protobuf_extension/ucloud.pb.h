// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ucloud.proto

#ifndef PROTOBUF_ucloud_2eproto__INCLUDED
#define PROTOBUF_ucloud_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace ucloud {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ucloud_2eproto();
void protobuf_AssignDesc_ucloud_2eproto();
void protobuf_ShutdownFile_ucloud_2eproto();

class UMessage;
class Head;
class Body;
class IpPortPair;
class ResponseCode;
class IpAddress;
class SimpleResponse;
class HeartBeatRequest;
class HeartBeatResponse;
class InternalHead;

enum MessageType {
  SIMPLE_RESPONSE = 10,
  HEART_BEAT_REQUEST = 12,
  HEART_BEAT_RESPONSE = 13
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = SIMPLE_RESPONSE;
const MessageType MessageType_MAX = HEART_BEAT_RESPONSE;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum ResourceType {
  RESOURCE_TYPE_UHOST = 1,
  RESOURCE_TYPE_UDISK = 3,
  RESOURCE_TYPE_SHARED_BANDWIDTH = 5,
  RESOURCE_TYPE_UDB = 6,
  RESOURCE_TYPE_UCDN = 7,
  RESOURCE_TYPE_USMS = 9,
  RESOURCE_TYPE_EIP = 10,
  RESOURCE_TYPE_ULB = 11,
  RESOURCE_TYPE_UMEM = 12,
  RESOURCE_TYPE_BANDWIDTH = 13,
  RESOURCE_TYPE_TRAFFIC = 14,
  RESOURCE_TYPE_ECSHOP = 15,
  RESOURCE_TYPE_VPN = 16,
  RESOURCE_TYPE_ACTUAL_BANDWIDTH = 17,
  RESOURCE_TYPE_ACTUAL_BIND_BANDWIDTH = 18,
  RESOURCE_TYPE_PHOST = 20,
  RESOURCE_TYPE_RACK = 21,
  RESOURCE_TYPE_PRIVATE_HOST = 22,
  RESOURCE_TYPE_PRIVATE_VM = 23,
  RESOURCE_TYPE_SAN = 24,
  RESOURCE_TYPE_MONGODB = 25,
  RESOURCE_TYPE_UMR = 26,
  RESOURCE_TYPE_UHIVE = 27
};
bool ResourceType_IsValid(int value);
const ResourceType ResourceType_MIN = RESOURCE_TYPE_UHOST;
const ResourceType ResourceType_MAX = RESOURCE_TYPE_UHIVE;
const int ResourceType_ARRAYSIZE = ResourceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResourceType_descriptor();
inline const ::std::string& ResourceType_Name(ResourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResourceType_descriptor(), value);
}
inline bool ResourceType_Parse(
    const ::std::string& name, ResourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResourceType>(
    ResourceType_descriptor(), name, value);
}
// ===================================================================

class UMessage : public ::google::protobuf::Message {
 public:
  UMessage();
  virtual ~UMessage();
  
  UMessage(const UMessage& from);
  
  inline UMessage& operator=(const UMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UMessage& default_instance();
  
  void Swap(UMessage* other);
  
  // implements Message ----------------------------------------------
  
  UMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UMessage& from);
  void MergeFrom(const UMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ucloud.Head head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::ucloud::Head& head() const;
  inline ::ucloud::Head* mutable_head();
  inline ::ucloud::Head* release_head();
  
  // required .ucloud.Body body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::ucloud::Body& body() const;
  inline ::ucloud::Body* mutable_body();
  inline ::ucloud::Body* release_body();
  
  // @@protoc_insertion_point(class_scope:ucloud.UMessage)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_body();
  inline void clear_has_body();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ucloud::Head* head_;
  ::ucloud::Body* body_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ucloud_2eproto();
  friend void protobuf_AssignDesc_ucloud_2eproto();
  friend void protobuf_ShutdownFile_ucloud_2eproto();
  
  void InitAsDefaultInstance();
  static UMessage* default_instance_;
};
// -------------------------------------------------------------------

class Head : public ::google::protobuf::Message {
 public:
  Head();
  virtual ~Head();
  
  Head(const Head& from);
  
  inline Head& operator=(const Head& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Head& default_instance();
  
  void Swap(Head* other);
  
  // implements Message ----------------------------------------------
  
  Head* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Head& from);
  void MergeFrom(const Head& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);
  
  // required uint32 magic_flag = 2 [default = 305400199];
  inline bool has_magic_flag() const;
  inline void clear_magic_flag();
  static const int kMagicFlagFieldNumber = 2;
  inline ::google::protobuf::uint32 magic_flag() const;
  inline void set_magic_flag(::google::protobuf::uint32 value);
  
  // required uint32 random_num = 3;
  inline bool has_random_num() const;
  inline void clear_random_num();
  static const int kRandomNumFieldNumber = 3;
  inline ::google::protobuf::uint32 random_num() const;
  inline void set_random_num(::google::protobuf::uint32 value);
  
  // required uint32 flow_no = 4;
  inline bool has_flow_no() const;
  inline void clear_flow_no();
  static const int kFlowNoFieldNumber = 4;
  inline ::google::protobuf::uint32 flow_no() const;
  inline void set_flow_no(::google::protobuf::uint32 value);
  
  // required string session_no = 5;
  inline bool has_session_no() const;
  inline void clear_session_no();
  static const int kSessionNoFieldNumber = 5;
  inline const ::std::string& session_no() const;
  inline void set_session_no(const ::std::string& value);
  inline void set_session_no(const char* value);
  inline void set_session_no(const char* value, size_t size);
  inline ::std::string* mutable_session_no();
  inline ::std::string* release_session_no();
  
  // required int32 message_type = 6;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 6;
  inline ::google::protobuf::int32 message_type() const;
  inline void set_message_type(::google::protobuf::int32 value);
  
  // required int32 worker_index = 7;
  inline bool has_worker_index() const;
  inline void clear_worker_index();
  static const int kWorkerIndexFieldNumber = 7;
  inline ::google::protobuf::int32 worker_index() const;
  inline void set_worker_index(::google::protobuf::int32 value);
  
  // optional bool tint_flag = 8;
  inline bool has_tint_flag() const;
  inline void clear_tint_flag();
  static const int kTintFlagFieldNumber = 8;
  inline bool tint_flag() const;
  inline void set_tint_flag(bool value);
  
  // required uint32 source_entity = 9;
  inline bool has_source_entity() const;
  inline void clear_source_entity();
  static const int kSourceEntityFieldNumber = 9;
  inline ::google::protobuf::uint32 source_entity() const;
  inline void set_source_entity(::google::protobuf::uint32 value);
  
  // optional uint32 dest_entity = 11;
  inline bool has_dest_entity() const;
  inline void clear_dest_entity();
  static const int kDestEntityFieldNumber = 11;
  inline ::google::protobuf::uint32 dest_entity() const;
  inline void set_dest_entity(::google::protobuf::uint32 value);
  
  // optional string call_purpose = 13;
  inline bool has_call_purpose() const;
  inline void clear_call_purpose();
  static const int kCallPurposeFieldNumber = 13;
  inline const ::std::string& call_purpose() const;
  inline void set_call_purpose(const ::std::string& value);
  inline void set_call_purpose(const char* value);
  inline void set_call_purpose(const char* value, size_t size);
  inline ::std::string* mutable_call_purpose();
  inline ::std::string* release_call_purpose();
  
  // optional bytes access_token = 14;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 14;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const void* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  
  // optional bytes reserved = 15;
  inline bool has_reserved() const;
  inline void clear_reserved();
  static const int kReservedFieldNumber = 15;
  inline const ::std::string& reserved() const;
  inline void set_reserved(const ::std::string& value);
  inline void set_reserved(const char* value);
  inline void set_reserved(const void* value, size_t size);
  inline ::std::string* mutable_reserved();
  inline ::std::string* release_reserved();
  
  // optional string client_ip = 20;
  inline bool has_client_ip() const;
  inline void clear_client_ip();
  static const int kClientIpFieldNumber = 20;
  inline const ::std::string& client_ip() const;
  inline void set_client_ip(const ::std::string& value);
  inline void set_client_ip(const char* value);
  inline void set_client_ip(const char* value, size_t size);
  inline ::std::string* mutable_client_ip();
  inline ::std::string* release_client_ip();
  
  // optional string target_ip = 30;
  inline bool has_target_ip() const;
  inline void clear_target_ip();
  static const int kTargetIpFieldNumber = 30;
  inline const ::std::string& target_ip() const;
  inline void set_target_ip(const ::std::string& value);
  inline void set_target_ip(const char* value);
  inline void set_target_ip(const char* value, size_t size);
  inline ::std::string* mutable_target_ip();
  inline ::std::string* release_target_ip();
  
  // optional uint32 target_port = 40;
  inline bool has_target_port() const;
  inline void clear_target_port();
  static const int kTargetPortFieldNumber = 40;
  inline ::google::protobuf::uint32 target_port() const;
  inline void set_target_port(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ucloud.Head)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_magic_flag();
  inline void clear_has_magic_flag();
  inline void set_has_random_num();
  inline void clear_has_random_num();
  inline void set_has_flow_no();
  inline void clear_has_flow_no();
  inline void set_has_session_no();
  inline void clear_has_session_no();
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_worker_index();
  inline void clear_has_worker_index();
  inline void set_has_tint_flag();
  inline void clear_has_tint_flag();
  inline void set_has_source_entity();
  inline void clear_has_source_entity();
  inline void set_has_dest_entity();
  inline void clear_has_dest_entity();
  inline void set_has_call_purpose();
  inline void clear_has_call_purpose();
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_reserved();
  inline void clear_has_reserved();
  inline void set_has_client_ip();
  inline void clear_has_client_ip();
  inline void set_has_target_ip();
  inline void clear_has_target_ip();
  inline void set_has_target_port();
  inline void clear_has_target_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 magic_flag_;
  ::google::protobuf::uint32 random_num_;
  ::google::protobuf::uint32 flow_no_;
  ::std::string* session_no_;
  ::google::protobuf::int32 message_type_;
  ::google::protobuf::int32 worker_index_;
  bool tint_flag_;
  ::google::protobuf::uint32 source_entity_;
  ::std::string* call_purpose_;
  ::std::string* access_token_;
  ::std::string* reserved_;
  ::google::protobuf::uint32 dest_entity_;
  ::google::protobuf::uint32 target_port_;
  ::std::string* client_ip_;
  ::std::string* target_ip_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_ucloud_2eproto();
  friend void protobuf_AssignDesc_ucloud_2eproto();
  friend void protobuf_ShutdownFile_ucloud_2eproto();
  
  void InitAsDefaultInstance();
  static Head* default_instance_;
};
// -------------------------------------------------------------------

class Body : public ::google::protobuf::Message {
 public:
  Body();
  virtual ~Body();
  
  Body(const Body& from);
  
  inline Body& operator=(const Body& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Body& default_instance();
  
  void Swap(Body* other);
  
  // implements Message ----------------------------------------------
  
  Body* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Body& from);
  void MergeFrom(const Body& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .ucloud.SimpleResponse simple_response = 1;
  inline bool has_simple_response() const;
  inline void clear_simple_response();
  static const int kSimpleResponseFieldNumber = 1;
  inline const ::ucloud::SimpleResponse& simple_response() const;
  inline ::ucloud::SimpleResponse* mutable_simple_response();
  inline ::ucloud::SimpleResponse* release_simple_response();
  
  // optional .ucloud.HeartBeatRequest heart_beat_request = 3;
  inline bool has_heart_beat_request() const;
  inline void clear_heart_beat_request();
  static const int kHeartBeatRequestFieldNumber = 3;
  inline const ::ucloud::HeartBeatRequest& heart_beat_request() const;
  inline ::ucloud::HeartBeatRequest* mutable_heart_beat_request();
  inline ::ucloud::HeartBeatRequest* release_heart_beat_request();
  
  // optional .ucloud.HeartBeatResponse heart_beat_response = 5;
  inline bool has_heart_beat_response() const;
  inline void clear_heart_beat_response();
  static const int kHeartBeatResponseFieldNumber = 5;
  inline const ::ucloud::HeartBeatResponse& heart_beat_response() const;
  inline ::ucloud::HeartBeatResponse* mutable_heart_beat_response();
  inline ::ucloud::HeartBeatResponse* release_heart_beat_response();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Body)
  // @@protoc_insertion_point(class_scope:ucloud.Body)
 private:
  inline void set_has_simple_response();
  inline void clear_has_simple_response();
  inline void set_has_heart_beat_request();
  inline void clear_has_heart_beat_request();
  inline void set_has_heart_beat_response();
  inline void clear_has_heart_beat_response();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ucloud::SimpleResponse* simple_response_;
  ::ucloud::HeartBeatRequest* heart_beat_request_;
  ::ucloud::HeartBeatResponse* heart_beat_response_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ucloud_2eproto();
  friend void protobuf_AssignDesc_ucloud_2eproto();
  friend void protobuf_ShutdownFile_ucloud_2eproto();
  
  void InitAsDefaultInstance();
  static Body* default_instance_;
};
// -------------------------------------------------------------------

class IpPortPair : public ::google::protobuf::Message {
 public:
  IpPortPair();
  virtual ~IpPortPair();
  
  IpPortPair(const IpPortPair& from);
  
  inline IpPortPair& operator=(const IpPortPair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IpPortPair& default_instance();
  
  void Swap(IpPortPair* other);
  
  // implements Message ----------------------------------------------
  
  IpPortPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IpPortPair& from);
  void MergeFrom(const IpPortPair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline ::google::protobuf::uint32 ip() const;
  inline void set_ip(::google::protobuf::uint32 value);
  
  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ucloud.IpPortPair)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 ip_;
  ::google::protobuf::uint32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ucloud_2eproto();
  friend void protobuf_AssignDesc_ucloud_2eproto();
  friend void protobuf_ShutdownFile_ucloud_2eproto();
  
  void InitAsDefaultInstance();
  static IpPortPair* default_instance_;
};
// -------------------------------------------------------------------

class ResponseCode : public ::google::protobuf::Message {
 public:
  ResponseCode();
  virtual ~ResponseCode();
  
  ResponseCode(const ResponseCode& from);
  
  inline ResponseCode& operator=(const ResponseCode& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseCode& default_instance();
  
  void Swap(ResponseCode* other);
  
  // implements Message ----------------------------------------------
  
  ResponseCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseCode& from);
  void MergeFrom(const ResponseCode& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 retcode = 1;
  inline bool has_retcode() const;
  inline void clear_retcode();
  static const int kRetcodeFieldNumber = 1;
  inline ::google::protobuf::int32 retcode() const;
  inline void set_retcode(::google::protobuf::int32 value);
  
  // optional string error_message = 2;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  
  // @@protoc_insertion_point(class_scope:ucloud.ResponseCode)
 private:
  inline void set_has_retcode();
  inline void clear_has_retcode();
  inline void set_has_error_message();
  inline void clear_has_error_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* error_message_;
  ::google::protobuf::int32 retcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ucloud_2eproto();
  friend void protobuf_AssignDesc_ucloud_2eproto();
  friend void protobuf_ShutdownFile_ucloud_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseCode* default_instance_;
};
// -------------------------------------------------------------------

class IpAddress : public ::google::protobuf::Message {
 public:
  IpAddress();
  virtual ~IpAddress();
  
  IpAddress(const IpAddress& from);
  
  inline IpAddress& operator=(const IpAddress& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IpAddress& default_instance();
  
  void Swap(IpAddress* other);
  
  // implements Message ----------------------------------------------
  
  IpAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IpAddress& from);
  void MergeFrom(const IpAddress& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // required uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:ucloud.IpAddress)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_;
  ::google::protobuf::uint32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ucloud_2eproto();
  friend void protobuf_AssignDesc_ucloud_2eproto();
  friend void protobuf_ShutdownFile_ucloud_2eproto();
  
  void InitAsDefaultInstance();
  static IpAddress* default_instance_;
};
// -------------------------------------------------------------------

class SimpleResponse : public ::google::protobuf::Message {
 public:
  SimpleResponse();
  virtual ~SimpleResponse();
  
  SimpleResponse(const SimpleResponse& from);
  
  inline SimpleResponse& operator=(const SimpleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleResponse& default_instance();
  
  void Swap(SimpleResponse* other);
  
  // implements Message ----------------------------------------------
  
  SimpleResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleResponse& from);
  void MergeFrom(const SimpleResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ucloud.ResponseCode rc = 1;
  inline bool has_rc() const;
  inline void clear_rc();
  static const int kRcFieldNumber = 1;
  inline const ::ucloud::ResponseCode& rc() const;
  inline ::ucloud::ResponseCode* mutable_rc();
  inline ::ucloud::ResponseCode* release_rc();
  
  // @@protoc_insertion_point(class_scope:ucloud.SimpleResponse)
 private:
  inline void set_has_rc();
  inline void clear_has_rc();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ucloud::ResponseCode* rc_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ucloud_2eproto();
  friend void protobuf_AssignDesc_ucloud_2eproto();
  friend void protobuf_ShutdownFile_ucloud_2eproto();
  
  void InitAsDefaultInstance();
  static SimpleResponse* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeatRequest : public ::google::protobuf::Message {
 public:
  HeartBeatRequest();
  virtual ~HeartBeatRequest();
  
  HeartBeatRequest(const HeartBeatRequest& from);
  
  inline HeartBeatRequest& operator=(const HeartBeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeatRequest& default_instance();
  
  void Swap(HeartBeatRequest* other);
  
  // implements Message ----------------------------------------------
  
  HeartBeatRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeatRequest& from);
  void MergeFrom(const HeartBeatRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated bytes payload = 1;
  inline int payload_size() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 1;
  inline const ::std::string& payload(int index) const;
  inline ::std::string* mutable_payload(int index);
  inline void set_payload(int index, const ::std::string& value);
  inline void set_payload(int index, const char* value);
  inline void set_payload(int index, const void* value, size_t size);
  inline ::std::string* add_payload();
  inline void add_payload(const ::std::string& value);
  inline void add_payload(const char* value);
  inline void add_payload(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& payload() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_payload();
  
  // @@protoc_insertion_point(class_scope:ucloud.HeartBeatRequest)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> payload_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ucloud_2eproto();
  friend void protobuf_AssignDesc_ucloud_2eproto();
  friend void protobuf_ShutdownFile_ucloud_2eproto();
  
  void InitAsDefaultInstance();
  static HeartBeatRequest* default_instance_;
};
// -------------------------------------------------------------------

class HeartBeatResponse : public ::google::protobuf::Message {
 public:
  HeartBeatResponse();
  virtual ~HeartBeatResponse();
  
  HeartBeatResponse(const HeartBeatResponse& from);
  
  inline HeartBeatResponse& operator=(const HeartBeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartBeatResponse& default_instance();
  
  void Swap(HeartBeatResponse* other);
  
  // implements Message ----------------------------------------------
  
  HeartBeatResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartBeatResponse& from);
  void MergeFrom(const HeartBeatResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .ucloud.ResponseCode rc = 1;
  inline bool has_rc() const;
  inline void clear_rc();
  static const int kRcFieldNumber = 1;
  inline const ::ucloud::ResponseCode& rc() const;
  inline ::ucloud::ResponseCode* mutable_rc();
  inline ::ucloud::ResponseCode* release_rc();
  
  // repeated bytes payload = 2;
  inline int payload_size() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 2;
  inline const ::std::string& payload(int index) const;
  inline ::std::string* mutable_payload(int index);
  inline void set_payload(int index, const ::std::string& value);
  inline void set_payload(int index, const char* value);
  inline void set_payload(int index, const void* value, size_t size);
  inline ::std::string* add_payload();
  inline void add_payload(const ::std::string& value);
  inline void add_payload(const char* value);
  inline void add_payload(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& payload() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_payload();
  
  // @@protoc_insertion_point(class_scope:ucloud.HeartBeatResponse)
 private:
  inline void set_has_rc();
  inline void clear_has_rc();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ucloud::ResponseCode* rc_;
  ::google::protobuf::RepeatedPtrField< ::std::string> payload_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ucloud_2eproto();
  friend void protobuf_AssignDesc_ucloud_2eproto();
  friend void protobuf_ShutdownFile_ucloud_2eproto();
  
  void InitAsDefaultInstance();
  static HeartBeatResponse* default_instance_;
};
// -------------------------------------------------------------------

class InternalHead : public ::google::protobuf::Message {
 public:
  InternalHead();
  virtual ~InternalHead();
  
  InternalHead(const InternalHead& from);
  
  inline InternalHead& operator=(const InternalHead& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalHead& default_instance();
  
  void Swap(InternalHead* other);
  
  // implements Message ----------------------------------------------
  
  InternalHead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalHead& from);
  void MergeFrom(const InternalHead& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 fd = 10;
  inline bool has_fd() const;
  inline void clear_fd();
  static const int kFdFieldNumber = 10;
  inline ::google::protobuf::int32 fd() const;
  inline void set_fd(::google::protobuf::int32 value);
  
  // required uint32 peer_addr = 20;
  inline bool has_peer_addr() const;
  inline void clear_peer_addr();
  static const int kPeerAddrFieldNumber = 20;
  inline ::google::protobuf::uint32 peer_addr() const;
  inline void set_peer_addr(::google::protobuf::uint32 value);
  
  // required int32 peer_port = 30;
  inline bool has_peer_port() const;
  inline void clear_peer_port();
  static const int kPeerPortFieldNumber = 30;
  inline ::google::protobuf::int32 peer_port() const;
  inline void set_peer_port(::google::protobuf::int32 value);
  
  // required uint32 sock_addr = 40;
  inline bool has_sock_addr() const;
  inline void clear_sock_addr();
  static const int kSockAddrFieldNumber = 40;
  inline ::google::protobuf::uint32 sock_addr() const;
  inline void set_sock_addr(::google::protobuf::uint32 value);
  
  // required int32 sock_port = 50;
  inline bool has_sock_port() const;
  inline void clear_sock_port();
  static const int kSockPortFieldNumber = 50;
  inline ::google::protobuf::int32 sock_port() const;
  inline void set_sock_port(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:ucloud.InternalHead)
 private:
  inline void set_has_fd();
  inline void clear_has_fd();
  inline void set_has_peer_addr();
  inline void clear_has_peer_addr();
  inline void set_has_peer_port();
  inline void clear_has_peer_port();
  inline void set_has_sock_addr();
  inline void clear_has_sock_addr();
  inline void set_has_sock_port();
  inline void clear_has_sock_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 fd_;
  ::google::protobuf::uint32 peer_addr_;
  ::google::protobuf::int32 peer_port_;
  ::google::protobuf::uint32 sock_addr_;
  ::google::protobuf::int32 sock_port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ucloud_2eproto();
  friend void protobuf_AssignDesc_ucloud_2eproto();
  friend void protobuf_ShutdownFile_ucloud_2eproto();
  
  void InitAsDefaultInstance();
  static InternalHead* default_instance_;
};
// ===================================================================


// ===================================================================

// UMessage

// required .ucloud.Head head = 1;
inline bool UMessage::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UMessage::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UMessage::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UMessage::clear_head() {
  if (head_ != NULL) head_->::ucloud::Head::Clear();
  clear_has_head();
}
inline const ::ucloud::Head& UMessage::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::ucloud::Head* UMessage::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::ucloud::Head;
  return head_;
}
inline ::ucloud::Head* UMessage::release_head() {
  clear_has_head();
  ::ucloud::Head* temp = head_;
  head_ = NULL;
  return temp;
}

// required .ucloud.Body body = 2;
inline bool UMessage::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UMessage::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UMessage::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UMessage::clear_body() {
  if (body_ != NULL) body_->::ucloud::Body::Clear();
  clear_has_body();
}
inline const ::ucloud::Body& UMessage::body() const {
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::ucloud::Body* UMessage::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::ucloud::Body;
  return body_;
}
inline ::ucloud::Body* UMessage::release_body() {
  clear_has_body();
  ::ucloud::Body* temp = body_;
  body_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Head

// required uint32 version = 1;
inline bool Head::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Head::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Head::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Head::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 Head::version() const {
  return version_;
}
inline void Head::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// required uint32 magic_flag = 2 [default = 305400199];
inline bool Head::has_magic_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Head::set_has_magic_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Head::clear_has_magic_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Head::clear_magic_flag() {
  magic_flag_ = 305400199u;
  clear_has_magic_flag();
}
inline ::google::protobuf::uint32 Head::magic_flag() const {
  return magic_flag_;
}
inline void Head::set_magic_flag(::google::protobuf::uint32 value) {
  set_has_magic_flag();
  magic_flag_ = value;
}

// required uint32 random_num = 3;
inline bool Head::has_random_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Head::set_has_random_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Head::clear_has_random_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Head::clear_random_num() {
  random_num_ = 0u;
  clear_has_random_num();
}
inline ::google::protobuf::uint32 Head::random_num() const {
  return random_num_;
}
inline void Head::set_random_num(::google::protobuf::uint32 value) {
  set_has_random_num();
  random_num_ = value;
}

// required uint32 flow_no = 4;
inline bool Head::has_flow_no() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Head::set_has_flow_no() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Head::clear_has_flow_no() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Head::clear_flow_no() {
  flow_no_ = 0u;
  clear_has_flow_no();
}
inline ::google::protobuf::uint32 Head::flow_no() const {
  return flow_no_;
}
inline void Head::set_flow_no(::google::protobuf::uint32 value) {
  set_has_flow_no();
  flow_no_ = value;
}

// required string session_no = 5;
inline bool Head::has_session_no() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Head::set_has_session_no() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Head::clear_has_session_no() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Head::clear_session_no() {
  if (session_no_ != &::google::protobuf::internal::kEmptyString) {
    session_no_->clear();
  }
  clear_has_session_no();
}
inline const ::std::string& Head::session_no() const {
  return *session_no_;
}
inline void Head::set_session_no(const ::std::string& value) {
  set_has_session_no();
  if (session_no_ == &::google::protobuf::internal::kEmptyString) {
    session_no_ = new ::std::string;
  }
  session_no_->assign(value);
}
inline void Head::set_session_no(const char* value) {
  set_has_session_no();
  if (session_no_ == &::google::protobuf::internal::kEmptyString) {
    session_no_ = new ::std::string;
  }
  session_no_->assign(value);
}
inline void Head::set_session_no(const char* value, size_t size) {
  set_has_session_no();
  if (session_no_ == &::google::protobuf::internal::kEmptyString) {
    session_no_ = new ::std::string;
  }
  session_no_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Head::mutable_session_no() {
  set_has_session_no();
  if (session_no_ == &::google::protobuf::internal::kEmptyString) {
    session_no_ = new ::std::string;
  }
  return session_no_;
}
inline ::std::string* Head::release_session_no() {
  clear_has_session_no();
  if (session_no_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_no_;
    session_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 message_type = 6;
inline bool Head::has_message_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Head::set_has_message_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Head::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Head::clear_message_type() {
  message_type_ = 0;
  clear_has_message_type();
}
inline ::google::protobuf::int32 Head::message_type() const {
  return message_type_;
}
inline void Head::set_message_type(::google::protobuf::int32 value) {
  set_has_message_type();
  message_type_ = value;
}

// required int32 worker_index = 7;
inline bool Head::has_worker_index() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Head::set_has_worker_index() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Head::clear_has_worker_index() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Head::clear_worker_index() {
  worker_index_ = 0;
  clear_has_worker_index();
}
inline ::google::protobuf::int32 Head::worker_index() const {
  return worker_index_;
}
inline void Head::set_worker_index(::google::protobuf::int32 value) {
  set_has_worker_index();
  worker_index_ = value;
}

// optional bool tint_flag = 8;
inline bool Head::has_tint_flag() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Head::set_has_tint_flag() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Head::clear_has_tint_flag() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Head::clear_tint_flag() {
  tint_flag_ = false;
  clear_has_tint_flag();
}
inline bool Head::tint_flag() const {
  return tint_flag_;
}
inline void Head::set_tint_flag(bool value) {
  set_has_tint_flag();
  tint_flag_ = value;
}

// required uint32 source_entity = 9;
inline bool Head::has_source_entity() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Head::set_has_source_entity() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Head::clear_has_source_entity() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Head::clear_source_entity() {
  source_entity_ = 0u;
  clear_has_source_entity();
}
inline ::google::protobuf::uint32 Head::source_entity() const {
  return source_entity_;
}
inline void Head::set_source_entity(::google::protobuf::uint32 value) {
  set_has_source_entity();
  source_entity_ = value;
}

// optional uint32 dest_entity = 11;
inline bool Head::has_dest_entity() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Head::set_has_dest_entity() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Head::clear_has_dest_entity() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Head::clear_dest_entity() {
  dest_entity_ = 0u;
  clear_has_dest_entity();
}
inline ::google::protobuf::uint32 Head::dest_entity() const {
  return dest_entity_;
}
inline void Head::set_dest_entity(::google::protobuf::uint32 value) {
  set_has_dest_entity();
  dest_entity_ = value;
}

// optional string call_purpose = 13;
inline bool Head::has_call_purpose() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Head::set_has_call_purpose() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Head::clear_has_call_purpose() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Head::clear_call_purpose() {
  if (call_purpose_ != &::google::protobuf::internal::kEmptyString) {
    call_purpose_->clear();
  }
  clear_has_call_purpose();
}
inline const ::std::string& Head::call_purpose() const {
  return *call_purpose_;
}
inline void Head::set_call_purpose(const ::std::string& value) {
  set_has_call_purpose();
  if (call_purpose_ == &::google::protobuf::internal::kEmptyString) {
    call_purpose_ = new ::std::string;
  }
  call_purpose_->assign(value);
}
inline void Head::set_call_purpose(const char* value) {
  set_has_call_purpose();
  if (call_purpose_ == &::google::protobuf::internal::kEmptyString) {
    call_purpose_ = new ::std::string;
  }
  call_purpose_->assign(value);
}
inline void Head::set_call_purpose(const char* value, size_t size) {
  set_has_call_purpose();
  if (call_purpose_ == &::google::protobuf::internal::kEmptyString) {
    call_purpose_ = new ::std::string;
  }
  call_purpose_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Head::mutable_call_purpose() {
  set_has_call_purpose();
  if (call_purpose_ == &::google::protobuf::internal::kEmptyString) {
    call_purpose_ = new ::std::string;
  }
  return call_purpose_;
}
inline ::std::string* Head::release_call_purpose() {
  clear_has_call_purpose();
  if (call_purpose_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = call_purpose_;
    call_purpose_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes access_token = 14;
inline bool Head::has_access_token() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Head::set_has_access_token() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Head::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Head::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::kEmptyString) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& Head::access_token() const {
  return *access_token_;
}
inline void Head::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void Head::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void Head::set_access_token(const void* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Head::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  return access_token_;
}
inline ::std::string* Head::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes reserved = 15;
inline bool Head::has_reserved() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Head::set_has_reserved() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Head::clear_has_reserved() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Head::clear_reserved() {
  if (reserved_ != &::google::protobuf::internal::kEmptyString) {
    reserved_->clear();
  }
  clear_has_reserved();
}
inline const ::std::string& Head::reserved() const {
  return *reserved_;
}
inline void Head::set_reserved(const ::std::string& value) {
  set_has_reserved();
  if (reserved_ == &::google::protobuf::internal::kEmptyString) {
    reserved_ = new ::std::string;
  }
  reserved_->assign(value);
}
inline void Head::set_reserved(const char* value) {
  set_has_reserved();
  if (reserved_ == &::google::protobuf::internal::kEmptyString) {
    reserved_ = new ::std::string;
  }
  reserved_->assign(value);
}
inline void Head::set_reserved(const void* value, size_t size) {
  set_has_reserved();
  if (reserved_ == &::google::protobuf::internal::kEmptyString) {
    reserved_ = new ::std::string;
  }
  reserved_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Head::mutable_reserved() {
  set_has_reserved();
  if (reserved_ == &::google::protobuf::internal::kEmptyString) {
    reserved_ = new ::std::string;
  }
  return reserved_;
}
inline ::std::string* Head::release_reserved() {
  clear_has_reserved();
  if (reserved_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reserved_;
    reserved_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string client_ip = 20;
inline bool Head::has_client_ip() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Head::set_has_client_ip() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Head::clear_has_client_ip() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Head::clear_client_ip() {
  if (client_ip_ != &::google::protobuf::internal::kEmptyString) {
    client_ip_->clear();
  }
  clear_has_client_ip();
}
inline const ::std::string& Head::client_ip() const {
  return *client_ip_;
}
inline void Head::set_client_ip(const ::std::string& value) {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  client_ip_->assign(value);
}
inline void Head::set_client_ip(const char* value) {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  client_ip_->assign(value);
}
inline void Head::set_client_ip(const char* value, size_t size) {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  client_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Head::mutable_client_ip() {
  set_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    client_ip_ = new ::std::string;
  }
  return client_ip_;
}
inline ::std::string* Head::release_client_ip() {
  clear_has_client_ip();
  if (client_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_ip_;
    client_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string target_ip = 30;
inline bool Head::has_target_ip() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Head::set_has_target_ip() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Head::clear_has_target_ip() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Head::clear_target_ip() {
  if (target_ip_ != &::google::protobuf::internal::kEmptyString) {
    target_ip_->clear();
  }
  clear_has_target_ip();
}
inline const ::std::string& Head::target_ip() const {
  return *target_ip_;
}
inline void Head::set_target_ip(const ::std::string& value) {
  set_has_target_ip();
  if (target_ip_ == &::google::protobuf::internal::kEmptyString) {
    target_ip_ = new ::std::string;
  }
  target_ip_->assign(value);
}
inline void Head::set_target_ip(const char* value) {
  set_has_target_ip();
  if (target_ip_ == &::google::protobuf::internal::kEmptyString) {
    target_ip_ = new ::std::string;
  }
  target_ip_->assign(value);
}
inline void Head::set_target_ip(const char* value, size_t size) {
  set_has_target_ip();
  if (target_ip_ == &::google::protobuf::internal::kEmptyString) {
    target_ip_ = new ::std::string;
  }
  target_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Head::mutable_target_ip() {
  set_has_target_ip();
  if (target_ip_ == &::google::protobuf::internal::kEmptyString) {
    target_ip_ = new ::std::string;
  }
  return target_ip_;
}
inline ::std::string* Head::release_target_ip() {
  clear_has_target_ip();
  if (target_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_ip_;
    target_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 target_port = 40;
inline bool Head::has_target_port() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Head::set_has_target_port() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Head::clear_has_target_port() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Head::clear_target_port() {
  target_port_ = 0u;
  clear_has_target_port();
}
inline ::google::protobuf::uint32 Head::target_port() const {
  return target_port_;
}
inline void Head::set_target_port(::google::protobuf::uint32 value) {
  set_has_target_port();
  target_port_ = value;
}

// -------------------------------------------------------------------

// Body

// optional .ucloud.SimpleResponse simple_response = 1;
inline bool Body::has_simple_response() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Body::set_has_simple_response() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Body::clear_has_simple_response() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Body::clear_simple_response() {
  if (simple_response_ != NULL) simple_response_->::ucloud::SimpleResponse::Clear();
  clear_has_simple_response();
}
inline const ::ucloud::SimpleResponse& Body::simple_response() const {
  return simple_response_ != NULL ? *simple_response_ : *default_instance_->simple_response_;
}
inline ::ucloud::SimpleResponse* Body::mutable_simple_response() {
  set_has_simple_response();
  if (simple_response_ == NULL) simple_response_ = new ::ucloud::SimpleResponse;
  return simple_response_;
}
inline ::ucloud::SimpleResponse* Body::release_simple_response() {
  clear_has_simple_response();
  ::ucloud::SimpleResponse* temp = simple_response_;
  simple_response_ = NULL;
  return temp;
}

// optional .ucloud.HeartBeatRequest heart_beat_request = 3;
inline bool Body::has_heart_beat_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Body::set_has_heart_beat_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Body::clear_has_heart_beat_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Body::clear_heart_beat_request() {
  if (heart_beat_request_ != NULL) heart_beat_request_->::ucloud::HeartBeatRequest::Clear();
  clear_has_heart_beat_request();
}
inline const ::ucloud::HeartBeatRequest& Body::heart_beat_request() const {
  return heart_beat_request_ != NULL ? *heart_beat_request_ : *default_instance_->heart_beat_request_;
}
inline ::ucloud::HeartBeatRequest* Body::mutable_heart_beat_request() {
  set_has_heart_beat_request();
  if (heart_beat_request_ == NULL) heart_beat_request_ = new ::ucloud::HeartBeatRequest;
  return heart_beat_request_;
}
inline ::ucloud::HeartBeatRequest* Body::release_heart_beat_request() {
  clear_has_heart_beat_request();
  ::ucloud::HeartBeatRequest* temp = heart_beat_request_;
  heart_beat_request_ = NULL;
  return temp;
}

// optional .ucloud.HeartBeatResponse heart_beat_response = 5;
inline bool Body::has_heart_beat_response() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Body::set_has_heart_beat_response() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Body::clear_has_heart_beat_response() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Body::clear_heart_beat_response() {
  if (heart_beat_response_ != NULL) heart_beat_response_->::ucloud::HeartBeatResponse::Clear();
  clear_has_heart_beat_response();
}
inline const ::ucloud::HeartBeatResponse& Body::heart_beat_response() const {
  return heart_beat_response_ != NULL ? *heart_beat_response_ : *default_instance_->heart_beat_response_;
}
inline ::ucloud::HeartBeatResponse* Body::mutable_heart_beat_response() {
  set_has_heart_beat_response();
  if (heart_beat_response_ == NULL) heart_beat_response_ = new ::ucloud::HeartBeatResponse;
  return heart_beat_response_;
}
inline ::ucloud::HeartBeatResponse* Body::release_heart_beat_response() {
  clear_has_heart_beat_response();
  ::ucloud::HeartBeatResponse* temp = heart_beat_response_;
  heart_beat_response_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// IpPortPair

// required uint32 ip = 1;
inline bool IpPortPair::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpPortPair::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpPortPair::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpPortPair::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
inline ::google::protobuf::uint32 IpPortPair::ip() const {
  return ip_;
}
inline void IpPortPair::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
}

// required uint32 port = 2;
inline bool IpPortPair::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpPortPair::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpPortPair::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpPortPair::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 IpPortPair::port() const {
  return port_;
}
inline void IpPortPair::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// ResponseCode

// required int32 retcode = 1;
inline bool ResponseCode::has_retcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseCode::set_has_retcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseCode::clear_has_retcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseCode::clear_retcode() {
  retcode_ = 0;
  clear_has_retcode();
}
inline ::google::protobuf::int32 ResponseCode::retcode() const {
  return retcode_;
}
inline void ResponseCode::set_retcode(::google::protobuf::int32 value) {
  set_has_retcode();
  retcode_ = value;
}

// optional string error_message = 2;
inline bool ResponseCode::has_error_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseCode::set_has_error_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseCode::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseCode::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& ResponseCode::error_message() const {
  return *error_message_;
}
inline void ResponseCode::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void ResponseCode::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void ResponseCode::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseCode::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  return error_message_;
}
inline ::std::string* ResponseCode::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// IpAddress

// required string ip = 1;
inline bool IpAddress::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpAddress::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpAddress::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpAddress::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& IpAddress::ip() const {
  return *ip_;
}
inline void IpAddress::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void IpAddress::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void IpAddress::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IpAddress::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* IpAddress::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 type = 2;
inline bool IpAddress::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpAddress::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpAddress::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpAddress::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 IpAddress::type() const {
  return type_;
}
inline void IpAddress::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// SimpleResponse

// required .ucloud.ResponseCode rc = 1;
inline bool SimpleResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimpleResponse::set_has_rc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimpleResponse::clear_has_rc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimpleResponse::clear_rc() {
  if (rc_ != NULL) rc_->::ucloud::ResponseCode::Clear();
  clear_has_rc();
}
inline const ::ucloud::ResponseCode& SimpleResponse::rc() const {
  return rc_ != NULL ? *rc_ : *default_instance_->rc_;
}
inline ::ucloud::ResponseCode* SimpleResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) rc_ = new ::ucloud::ResponseCode;
  return rc_;
}
inline ::ucloud::ResponseCode* SimpleResponse::release_rc() {
  clear_has_rc();
  ::ucloud::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// HeartBeatRequest

// repeated bytes payload = 1;
inline int HeartBeatRequest::payload_size() const {
  return payload_.size();
}
inline void HeartBeatRequest::clear_payload() {
  payload_.Clear();
}
inline const ::std::string& HeartBeatRequest::payload(int index) const {
  return payload_.Get(index);
}
inline ::std::string* HeartBeatRequest::mutable_payload(int index) {
  return payload_.Mutable(index);
}
inline void HeartBeatRequest::set_payload(int index, const ::std::string& value) {
  payload_.Mutable(index)->assign(value);
}
inline void HeartBeatRequest::set_payload(int index, const char* value) {
  payload_.Mutable(index)->assign(value);
}
inline void HeartBeatRequest::set_payload(int index, const void* value, size_t size) {
  payload_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeartBeatRequest::add_payload() {
  return payload_.Add();
}
inline void HeartBeatRequest::add_payload(const ::std::string& value) {
  payload_.Add()->assign(value);
}
inline void HeartBeatRequest::add_payload(const char* value) {
  payload_.Add()->assign(value);
}
inline void HeartBeatRequest::add_payload(const void* value, size_t size) {
  payload_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeartBeatRequest::payload() const {
  return payload_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeartBeatRequest::mutable_payload() {
  return &payload_;
}

// -------------------------------------------------------------------

// HeartBeatResponse

// required .ucloud.ResponseCode rc = 1;
inline bool HeartBeatResponse::has_rc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartBeatResponse::set_has_rc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartBeatResponse::clear_has_rc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartBeatResponse::clear_rc() {
  if (rc_ != NULL) rc_->::ucloud::ResponseCode::Clear();
  clear_has_rc();
}
inline const ::ucloud::ResponseCode& HeartBeatResponse::rc() const {
  return rc_ != NULL ? *rc_ : *default_instance_->rc_;
}
inline ::ucloud::ResponseCode* HeartBeatResponse::mutable_rc() {
  set_has_rc();
  if (rc_ == NULL) rc_ = new ::ucloud::ResponseCode;
  return rc_;
}
inline ::ucloud::ResponseCode* HeartBeatResponse::release_rc() {
  clear_has_rc();
  ::ucloud::ResponseCode* temp = rc_;
  rc_ = NULL;
  return temp;
}

// repeated bytes payload = 2;
inline int HeartBeatResponse::payload_size() const {
  return payload_.size();
}
inline void HeartBeatResponse::clear_payload() {
  payload_.Clear();
}
inline const ::std::string& HeartBeatResponse::payload(int index) const {
  return payload_.Get(index);
}
inline ::std::string* HeartBeatResponse::mutable_payload(int index) {
  return payload_.Mutable(index);
}
inline void HeartBeatResponse::set_payload(int index, const ::std::string& value) {
  payload_.Mutable(index)->assign(value);
}
inline void HeartBeatResponse::set_payload(int index, const char* value) {
  payload_.Mutable(index)->assign(value);
}
inline void HeartBeatResponse::set_payload(int index, const void* value, size_t size) {
  payload_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeartBeatResponse::add_payload() {
  return payload_.Add();
}
inline void HeartBeatResponse::add_payload(const ::std::string& value) {
  payload_.Add()->assign(value);
}
inline void HeartBeatResponse::add_payload(const char* value) {
  payload_.Add()->assign(value);
}
inline void HeartBeatResponse::add_payload(const void* value, size_t size) {
  payload_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeartBeatResponse::payload() const {
  return payload_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeartBeatResponse::mutable_payload() {
  return &payload_;
}

// -------------------------------------------------------------------

// InternalHead

// required int32 fd = 10;
inline bool InternalHead::has_fd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalHead::set_has_fd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalHead::clear_has_fd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalHead::clear_fd() {
  fd_ = 0;
  clear_has_fd();
}
inline ::google::protobuf::int32 InternalHead::fd() const {
  return fd_;
}
inline void InternalHead::set_fd(::google::protobuf::int32 value) {
  set_has_fd();
  fd_ = value;
}

// required uint32 peer_addr = 20;
inline bool InternalHead::has_peer_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalHead::set_has_peer_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalHead::clear_has_peer_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalHead::clear_peer_addr() {
  peer_addr_ = 0u;
  clear_has_peer_addr();
}
inline ::google::protobuf::uint32 InternalHead::peer_addr() const {
  return peer_addr_;
}
inline void InternalHead::set_peer_addr(::google::protobuf::uint32 value) {
  set_has_peer_addr();
  peer_addr_ = value;
}

// required int32 peer_port = 30;
inline bool InternalHead::has_peer_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalHead::set_has_peer_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalHead::clear_has_peer_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalHead::clear_peer_port() {
  peer_port_ = 0;
  clear_has_peer_port();
}
inline ::google::protobuf::int32 InternalHead::peer_port() const {
  return peer_port_;
}
inline void InternalHead::set_peer_port(::google::protobuf::int32 value) {
  set_has_peer_port();
  peer_port_ = value;
}

// required uint32 sock_addr = 40;
inline bool InternalHead::has_sock_addr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InternalHead::set_has_sock_addr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InternalHead::clear_has_sock_addr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InternalHead::clear_sock_addr() {
  sock_addr_ = 0u;
  clear_has_sock_addr();
}
inline ::google::protobuf::uint32 InternalHead::sock_addr() const {
  return sock_addr_;
}
inline void InternalHead::set_sock_addr(::google::protobuf::uint32 value) {
  set_has_sock_addr();
  sock_addr_ = value;
}

// required int32 sock_port = 50;
inline bool InternalHead::has_sock_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InternalHead::set_has_sock_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InternalHead::clear_has_sock_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InternalHead::clear_sock_port() {
  sock_port_ = 0;
  clear_has_sock_port();
}
inline ::google::protobuf::int32 InternalHead::sock_port() const {
  return sock_port_;
}
inline void InternalHead::set_sock_port(::google::protobuf::int32 value) {
  set_has_sock_port();
  sock_port_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ucloud

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ucloud::MessageType>() {
  return ucloud::MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ucloud::ResourceType>() {
  return ucloud::ResourceType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ucloud_2eproto__INCLUDED
