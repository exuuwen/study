// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ucloud.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace ucloud {

namespace {

const ::google::protobuf::Descriptor* UMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* Head_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Head_reflection_ = NULL;
const ::google::protobuf::Descriptor* Body_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Body_reflection_ = NULL;
const ::google::protobuf::Descriptor* IpPortPair_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IpPortPair_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResponseCode_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResponseCode_reflection_ = NULL;
const ::google::protobuf::Descriptor* IpAddress_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IpAddress_reflection_ = NULL;
const ::google::protobuf::Descriptor* SimpleResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SimpleResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* HeartBeatRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HeartBeatRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* HeartBeatResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HeartBeatResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* InternalHead_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InternalHead_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* MessageType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ResourceType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_ucloud_2eproto() {
  protobuf_AddDesc_ucloud_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "ucloud.proto");
  GOOGLE_CHECK(file != NULL);
  UMessage_descriptor_ = file->message_type(0);
  static const int UMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UMessage, head_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UMessage, body_),
  };
  UMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UMessage_descriptor_,
      UMessage::default_instance_,
      UMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UMessage));
  Head_descriptor_ = file->message_type(1);
  static const int Head_offsets_[16] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, magic_flag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, random_num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, flow_no_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, session_no_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, message_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, worker_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, tint_flag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, source_entity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, dest_entity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, call_purpose_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, access_token_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, reserved_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, client_ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, target_ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, target_port_),
  };
  Head_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Head_descriptor_,
      Head::default_instance_,
      Head_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Head, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Head));
  Body_descriptor_ = file->message_type(2);
  static const int Body_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Body, simple_response_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Body, heart_beat_request_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Body, heart_beat_response_),
  };
  Body_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Body_descriptor_,
      Body::default_instance_,
      Body_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Body, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Body, _unknown_fields_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Body, _extensions_),
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Body));
  IpPortPair_descriptor_ = file->message_type(3);
  static const int IpPortPair_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpPortPair, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpPortPair, port_),
  };
  IpPortPair_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IpPortPair_descriptor_,
      IpPortPair::default_instance_,
      IpPortPair_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpPortPair, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpPortPair, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IpPortPair));
  ResponseCode_descriptor_ = file->message_type(4);
  static const int ResponseCode_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseCode, retcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseCode, error_message_),
  };
  ResponseCode_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResponseCode_descriptor_,
      ResponseCode::default_instance_,
      ResponseCode_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseCode, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseCode, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResponseCode));
  IpAddress_descriptor_ = file->message_type(5);
  static const int IpAddress_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpAddress, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpAddress, type_),
  };
  IpAddress_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IpAddress_descriptor_,
      IpAddress::default_instance_,
      IpAddress_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpAddress, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpAddress, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IpAddress));
  SimpleResponse_descriptor_ = file->message_type(6);
  static const int SimpleResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleResponse, rc_),
  };
  SimpleResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SimpleResponse_descriptor_,
      SimpleResponse::default_instance_,
      SimpleResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SimpleResponse));
  HeartBeatRequest_descriptor_ = file->message_type(7);
  static const int HeartBeatRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartBeatRequest, payload_),
  };
  HeartBeatRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HeartBeatRequest_descriptor_,
      HeartBeatRequest::default_instance_,
      HeartBeatRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartBeatRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartBeatRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HeartBeatRequest));
  HeartBeatResponse_descriptor_ = file->message_type(8);
  static const int HeartBeatResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartBeatResponse, rc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartBeatResponse, payload_),
  };
  HeartBeatResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HeartBeatResponse_descriptor_,
      HeartBeatResponse::default_instance_,
      HeartBeatResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartBeatResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartBeatResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HeartBeatResponse));
  InternalHead_descriptor_ = file->message_type(9);
  static const int InternalHead_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InternalHead, fd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InternalHead, peer_addr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InternalHead, peer_port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InternalHead, sock_addr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InternalHead, sock_port_),
  };
  InternalHead_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InternalHead_descriptor_,
      InternalHead::default_instance_,
      InternalHead_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InternalHead, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InternalHead, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InternalHead));
  MessageType_descriptor_ = file->enum_type(0);
  ResourceType_descriptor_ = file->enum_type(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_ucloud_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UMessage_descriptor_, &UMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Head_descriptor_, &Head::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Body_descriptor_, &Body::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IpPortPair_descriptor_, &IpPortPair::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResponseCode_descriptor_, &ResponseCode::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IpAddress_descriptor_, &IpAddress::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SimpleResponse_descriptor_, &SimpleResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HeartBeatRequest_descriptor_, &HeartBeatRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HeartBeatResponse_descriptor_, &HeartBeatResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InternalHead_descriptor_, &InternalHead::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_ucloud_2eproto() {
  delete UMessage::default_instance_;
  delete UMessage_reflection_;
  delete Head::default_instance_;
  delete Head_reflection_;
  delete Body::default_instance_;
  delete Body_reflection_;
  delete IpPortPair::default_instance_;
  delete IpPortPair_reflection_;
  delete ResponseCode::default_instance_;
  delete ResponseCode_reflection_;
  delete IpAddress::default_instance_;
  delete IpAddress_reflection_;
  delete SimpleResponse::default_instance_;
  delete SimpleResponse_reflection_;
  delete HeartBeatRequest::default_instance_;
  delete HeartBeatRequest_reflection_;
  delete HeartBeatResponse::default_instance_;
  delete HeartBeatResponse_reflection_;
  delete InternalHead::default_instance_;
  delete InternalHead_reflection_;
}

void protobuf_AddDesc_ucloud_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014ucloud.proto\022\006ucloud\"B\n\010UMessage\022\032\n\004he"
    "ad\030\001 \002(\0132\014.ucloud.Head\022\032\n\004body\030\002 \002(\0132\014.u"
    "cloud.Body\"\323\002\n\004Head\022\017\n\007version\030\001 \002(\r\022\035\n\n"
    "magic_flag\030\002 \002(\r:\t305400199\022\022\n\nrandom_nu"
    "m\030\003 \002(\r\022\017\n\007flow_no\030\004 \002(\r\022\022\n\nsession_no\030\005"
    " \002(\t\022\024\n\014message_type\030\006 \002(\005\022\024\n\014worker_ind"
    "ex\030\007 \002(\005\022\021\n\ttint_flag\030\010 \001(\010\022\025\n\rsource_en"
    "tity\030\t \002(\r\022\023\n\013dest_entity\030\013 \001(\r\022\024\n\014call_"
    "purpose\030\r \001(\t\022\024\n\014access_token\030\016 \001(\014\022\020\n\010r"
    "eserved\030\017 \001(\014\022\021\n\tclient_ip\030\024 \001(\t\022\021\n\ttarg"
    "et_ip\030\036 \001(\t\022\023\n\013target_port\030( \001(\r\"\257\001\n\004Bod"
    "y\022/\n\017simple_response\030\001 \001(\0132\026.ucloud.Simp"
    "leResponse\0224\n\022heart_beat_request\030\003 \001(\0132\030"
    ".ucloud.HeartBeatRequest\0226\n\023heart_beat_r"
    "esponse\030\005 \001(\0132\031.ucloud.HeartBeatResponse"
    "*\010\010d\020\200\200\200\200\002\"&\n\nIpPortPair\022\n\n\002ip\030\001 \002(\r\022\014\n\004"
    "port\030\002 \002(\r\"6\n\014ResponseCode\022\017\n\007retcode\030\001 "
    "\002(\005\022\025\n\rerror_message\030\002 \001(\t\"%\n\tIpAddress\022"
    "\n\n\002ip\030\001 \002(\t\022\014\n\004type\030\002 \002(\r\"2\n\016SimpleRespo"
    "nse\022 \n\002rc\030\001 \002(\0132\024.ucloud.ResponseCode\"#\n"
    "\020HeartBeatRequest\022\017\n\007payload\030\001 \003(\014\"F\n\021He"
    "artBeatResponse\022 \n\002rc\030\001 \002(\0132\024.ucloud.Res"
    "ponseCode\022\017\n\007payload\030\002 \003(\014\"f\n\014InternalHe"
    "ad\022\n\n\002fd\030\n \002(\005\022\021\n\tpeer_addr\030\024 \002(\r\022\021\n\tpee"
    "r_port\030\036 \002(\005\022\021\n\tsock_addr\030( \002(\r\022\021\n\tsock_"
    "port\0302 \002(\005*S\n\013MessageType\022\023\n\017SIMPLE_RESP"
    "ONSE\020\n\022\026\n\022HEART_BEAT_REQUEST\020\014\022\027\n\023HEART_"
    "BEAT_RESPONSE\020\r*\370\004\n\014ResourceType\022\027\n\023RESO"
    "URCE_TYPE_UHOST\020\001\022\027\n\023RESOURCE_TYPE_UDISK"
    "\020\003\022\"\n\036RESOURCE_TYPE_SHARED_BANDWIDTH\020\005\022\025"
    "\n\021RESOURCE_TYPE_UDB\020\006\022\026\n\022RESOURCE_TYPE_U"
    "CDN\020\007\022\026\n\022RESOURCE_TYPE_USMS\020\t\022\025\n\021RESOURC"
    "E_TYPE_EIP\020\n\022\025\n\021RESOURCE_TYPE_ULB\020\013\022\026\n\022R"
    "ESOURCE_TYPE_UMEM\020\014\022\033\n\027RESOURCE_TYPE_BAN"
    "DWIDTH\020\r\022\031\n\025RESOURCE_TYPE_TRAFFIC\020\016\022\030\n\024R"
    "ESOURCE_TYPE_ECSHOP\020\017\022\025\n\021RESOURCE_TYPE_V"
    "PN\020\020\022\"\n\036RESOURCE_TYPE_ACTUAL_BANDWIDTH\020\021"
    "\022\'\n#RESOURCE_TYPE_ACTUAL_BIND_BANDWIDTH\020"
    "\022\022\027\n\023RESOURCE_TYPE_PHOST\020\024\022\026\n\022RESOURCE_T"
    "YPE_RACK\020\025\022\036\n\032RESOURCE_TYPE_PRIVATE_HOST"
    "\020\026\022\034\n\030RESOURCE_TYPE_PRIVATE_VM\020\027\022\025\n\021RESO"
    "URCE_TYPE_SAN\020\030\022\031\n\025RESOURCE_TYPE_MONGODB"
    "\020\031\022\025\n\021RESOURCE_TYPE_UMR\020\032\022\027\n\023RESOURCE_TY"
    "PE_UHIVE\020\033", 1730);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "ucloud.proto", &protobuf_RegisterTypes);
  UMessage::default_instance_ = new UMessage();
  Head::default_instance_ = new Head();
  Body::default_instance_ = new Body();
  IpPortPair::default_instance_ = new IpPortPair();
  ResponseCode::default_instance_ = new ResponseCode();
  IpAddress::default_instance_ = new IpAddress();
  SimpleResponse::default_instance_ = new SimpleResponse();
  HeartBeatRequest::default_instance_ = new HeartBeatRequest();
  HeartBeatResponse::default_instance_ = new HeartBeatResponse();
  InternalHead::default_instance_ = new InternalHead();
  UMessage::default_instance_->InitAsDefaultInstance();
  Head::default_instance_->InitAsDefaultInstance();
  Body::default_instance_->InitAsDefaultInstance();
  IpPortPair::default_instance_->InitAsDefaultInstance();
  ResponseCode::default_instance_->InitAsDefaultInstance();
  IpAddress::default_instance_->InitAsDefaultInstance();
  SimpleResponse::default_instance_->InitAsDefaultInstance();
  HeartBeatRequest::default_instance_->InitAsDefaultInstance();
  HeartBeatResponse::default_instance_->InitAsDefaultInstance();
  InternalHead::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ucloud_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ucloud_2eproto {
  StaticDescriptorInitializer_ucloud_2eproto() {
    protobuf_AddDesc_ucloud_2eproto();
  }
} static_descriptor_initializer_ucloud_2eproto_;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MessageType_descriptor_;
}
bool MessageType_IsValid(int value) {
  switch(value) {
    case 10:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ResourceType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceType_descriptor_;
}
bool ResourceType_IsValid(int value) {
  switch(value) {
    case 1:
    case 3:
    case 5:
    case 6:
    case 7:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int UMessage::kHeadFieldNumber;
const int UMessage::kBodyFieldNumber;
#endif  // !_MSC_VER

UMessage::UMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UMessage::InitAsDefaultInstance() {
  head_ = const_cast< ::ucloud::Head*>(&::ucloud::Head::default_instance());
  body_ = const_cast< ::ucloud::Body*>(&::ucloud::Body::default_instance());
}

UMessage::UMessage(const UMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UMessage::SharedCtor() {
  _cached_size_ = 0;
  head_ = NULL;
  body_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UMessage::~UMessage() {
  SharedDtor();
}

void UMessage::SharedDtor() {
  if (this != default_instance_) {
    delete head_;
    delete body_;
  }
}

void UMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UMessage_descriptor_;
}

const UMessage& UMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ucloud_2eproto();  return *default_instance_;
}

UMessage* UMessage::default_instance_ = NULL;

UMessage* UMessage::New() const {
  return new UMessage;
}

void UMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_head()) {
      if (head_ != NULL) head_->::ucloud::Head::Clear();
    }
    if (has_body()) {
      if (body_ != NULL) body_->::ucloud::Body::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ucloud.Head head = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_head()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_body;
        break;
      }
      
      // required .ucloud.Body body = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_body:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_body()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ucloud.Head head = 1;
  if (has_head()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->head(), output);
  }
  
  // required .ucloud.Body body = 2;
  if (has_body()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->body(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ucloud.Head head = 1;
  if (has_head()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->head(), target);
  }
  
  // required .ucloud.Body body = 2;
  if (has_body()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->body(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UMessage::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ucloud.Head head = 1;
    if (has_head()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->head());
    }
    
    // required .ucloud.Body body = 2;
    if (has_body()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->body());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UMessage::MergeFrom(const UMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_head()) {
      mutable_head()->::ucloud::Head::MergeFrom(from.head());
    }
    if (from.has_body()) {
      mutable_body()->::ucloud::Body::MergeFrom(from.body());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UMessage::CopyFrom(const UMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_head()) {
    if (!this->head().IsInitialized()) return false;
  }
  if (has_body()) {
    if (!this->body().IsInitialized()) return false;
  }
  return true;
}

void UMessage::Swap(UMessage* other) {
  if (other != this) {
    std::swap(head_, other->head_);
    std::swap(body_, other->body_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UMessage_descriptor_;
  metadata.reflection = UMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Head::kVersionFieldNumber;
const int Head::kMagicFlagFieldNumber;
const int Head::kRandomNumFieldNumber;
const int Head::kFlowNoFieldNumber;
const int Head::kSessionNoFieldNumber;
const int Head::kMessageTypeFieldNumber;
const int Head::kWorkerIndexFieldNumber;
const int Head::kTintFlagFieldNumber;
const int Head::kSourceEntityFieldNumber;
const int Head::kDestEntityFieldNumber;
const int Head::kCallPurposeFieldNumber;
const int Head::kAccessTokenFieldNumber;
const int Head::kReservedFieldNumber;
const int Head::kClientIpFieldNumber;
const int Head::kTargetIpFieldNumber;
const int Head::kTargetPortFieldNumber;
#endif  // !_MSC_VER

Head::Head()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Head::InitAsDefaultInstance() {
}

Head::Head(const Head& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Head::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  magic_flag_ = 305400199u;
  random_num_ = 0u;
  flow_no_ = 0u;
  session_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  message_type_ = 0;
  worker_index_ = 0;
  tint_flag_ = false;
  source_entity_ = 0u;
  dest_entity_ = 0u;
  call_purpose_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  reserved_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  client_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  target_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  target_port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Head::~Head() {
  SharedDtor();
}

void Head::SharedDtor() {
  if (session_no_ != &::google::protobuf::internal::kEmptyString) {
    delete session_no_;
  }
  if (call_purpose_ != &::google::protobuf::internal::kEmptyString) {
    delete call_purpose_;
  }
  if (access_token_ != &::google::protobuf::internal::kEmptyString) {
    delete access_token_;
  }
  if (reserved_ != &::google::protobuf::internal::kEmptyString) {
    delete reserved_;
  }
  if (client_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete client_ip_;
  }
  if (target_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete target_ip_;
  }
  if (this != default_instance_) {
  }
}

void Head::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Head::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Head_descriptor_;
}

const Head& Head::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ucloud_2eproto();  return *default_instance_;
}

Head* Head::default_instance_ = NULL;

Head* Head::New() const {
  return new Head;
}

void Head::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    magic_flag_ = 305400199u;
    random_num_ = 0u;
    flow_no_ = 0u;
    if (has_session_no()) {
      if (session_no_ != &::google::protobuf::internal::kEmptyString) {
        session_no_->clear();
      }
    }
    message_type_ = 0;
    worker_index_ = 0;
    tint_flag_ = false;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    source_entity_ = 0u;
    dest_entity_ = 0u;
    if (has_call_purpose()) {
      if (call_purpose_ != &::google::protobuf::internal::kEmptyString) {
        call_purpose_->clear();
      }
    }
    if (has_access_token()) {
      if (access_token_ != &::google::protobuf::internal::kEmptyString) {
        access_token_->clear();
      }
    }
    if (has_reserved()) {
      if (reserved_ != &::google::protobuf::internal::kEmptyString) {
        reserved_->clear();
      }
    }
    if (has_client_ip()) {
      if (client_ip_ != &::google::protobuf::internal::kEmptyString) {
        client_ip_->clear();
      }
    }
    if (has_target_ip()) {
      if (target_ip_ != &::google::protobuf::internal::kEmptyString) {
        target_ip_->clear();
      }
    }
    target_port_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Head::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_magic_flag;
        break;
      }
      
      // required uint32 magic_flag = 2 [default = 305400199];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_magic_flag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &magic_flag_)));
          set_has_magic_flag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_random_num;
        break;
      }
      
      // required uint32 random_num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_random_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &random_num_)));
          set_has_random_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_flow_no;
        break;
      }
      
      // required uint32 flow_no = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flow_no:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flow_no_)));
          set_has_flow_no();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_session_no;
        break;
      }
      
      // required string session_no = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_session_no:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_session_no()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->session_no().data(), this->session_no().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_message_type;
        break;
      }
      
      // required int32 message_type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_message_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &message_type_)));
          set_has_message_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_worker_index;
        break;
      }
      
      // required int32 worker_index = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_worker_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &worker_index_)));
          set_has_worker_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_tint_flag;
        break;
      }
      
      // optional bool tint_flag = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tint_flag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &tint_flag_)));
          set_has_tint_flag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_source_entity;
        break;
      }
      
      // required uint32 source_entity = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_source_entity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &source_entity_)));
          set_has_source_entity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_dest_entity;
        break;
      }
      
      // optional uint32 dest_entity = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_dest_entity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dest_entity_)));
          set_has_dest_entity();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_call_purpose;
        break;
      }
      
      // optional string call_purpose = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_call_purpose:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_call_purpose()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->call_purpose().data(), this->call_purpose().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_access_token;
        break;
      }
      
      // optional bytes access_token = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_access_token:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_access_token()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_reserved;
        break;
      }
      
      // optional bytes reserved = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reserved:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_reserved()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_client_ip;
        break;
      }
      
      // optional string client_ip = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_client_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_client_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->client_ip().data(), this->client_ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(242)) goto parse_target_ip;
        break;
      }
      
      // optional string target_ip = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_target_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_target_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->target_ip().data(), this->target_ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(320)) goto parse_target_port;
        break;
      }
      
      // optional uint32 target_port = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_port_)));
          set_has_target_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Head::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }
  
  // required uint32 magic_flag = 2 [default = 305400199];
  if (has_magic_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->magic_flag(), output);
  }
  
  // required uint32 random_num = 3;
  if (has_random_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->random_num(), output);
  }
  
  // required uint32 flow_no = 4;
  if (has_flow_no()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->flow_no(), output);
  }
  
  // required string session_no = 5;
  if (has_session_no()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->session_no().data(), this->session_no().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->session_no(), output);
  }
  
  // required int32 message_type = 6;
  if (has_message_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->message_type(), output);
  }
  
  // required int32 worker_index = 7;
  if (has_worker_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->worker_index(), output);
  }
  
  // optional bool tint_flag = 8;
  if (has_tint_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->tint_flag(), output);
  }
  
  // required uint32 source_entity = 9;
  if (has_source_entity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->source_entity(), output);
  }
  
  // optional uint32 dest_entity = 11;
  if (has_dest_entity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->dest_entity(), output);
  }
  
  // optional string call_purpose = 13;
  if (has_call_purpose()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->call_purpose().data(), this->call_purpose().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      13, this->call_purpose(), output);
  }
  
  // optional bytes access_token = 14;
  if (has_access_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      14, this->access_token(), output);
  }
  
  // optional bytes reserved = 15;
  if (has_reserved()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      15, this->reserved(), output);
  }
  
  // optional string client_ip = 20;
  if (has_client_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->client_ip().data(), this->client_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      20, this->client_ip(), output);
  }
  
  // optional string target_ip = 30;
  if (has_target_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->target_ip().data(), this->target_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      30, this->target_ip(), output);
  }
  
  // optional uint32 target_port = 40;
  if (has_target_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(40, this->target_port(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Head::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }
  
  // required uint32 magic_flag = 2 [default = 305400199];
  if (has_magic_flag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->magic_flag(), target);
  }
  
  // required uint32 random_num = 3;
  if (has_random_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->random_num(), target);
  }
  
  // required uint32 flow_no = 4;
  if (has_flow_no()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->flow_no(), target);
  }
  
  // required string session_no = 5;
  if (has_session_no()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->session_no().data(), this->session_no().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->session_no(), target);
  }
  
  // required int32 message_type = 6;
  if (has_message_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->message_type(), target);
  }
  
  // required int32 worker_index = 7;
  if (has_worker_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->worker_index(), target);
  }
  
  // optional bool tint_flag = 8;
  if (has_tint_flag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->tint_flag(), target);
  }
  
  // required uint32 source_entity = 9;
  if (has_source_entity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->source_entity(), target);
  }
  
  // optional uint32 dest_entity = 11;
  if (has_dest_entity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->dest_entity(), target);
  }
  
  // optional string call_purpose = 13;
  if (has_call_purpose()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->call_purpose().data(), this->call_purpose().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->call_purpose(), target);
  }
  
  // optional bytes access_token = 14;
  if (has_access_token()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        14, this->access_token(), target);
  }
  
  // optional bytes reserved = 15;
  if (has_reserved()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        15, this->reserved(), target);
  }
  
  // optional string client_ip = 20;
  if (has_client_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->client_ip().data(), this->client_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        20, this->client_ip(), target);
  }
  
  // optional string target_ip = 30;
  if (has_target_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->target_ip().data(), this->target_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        30, this->target_ip(), target);
  }
  
  // optional uint32 target_port = 40;
  if (has_target_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(40, this->target_port(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Head::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }
    
    // required uint32 magic_flag = 2 [default = 305400199];
    if (has_magic_flag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->magic_flag());
    }
    
    // required uint32 random_num = 3;
    if (has_random_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->random_num());
    }
    
    // required uint32 flow_no = 4;
    if (has_flow_no()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flow_no());
    }
    
    // required string session_no = 5;
    if (has_session_no()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->session_no());
    }
    
    // required int32 message_type = 6;
    if (has_message_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->message_type());
    }
    
    // required int32 worker_index = 7;
    if (has_worker_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->worker_index());
    }
    
    // optional bool tint_flag = 8;
    if (has_tint_flag()) {
      total_size += 1 + 1;
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 source_entity = 9;
    if (has_source_entity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->source_entity());
    }
    
    // optional uint32 dest_entity = 11;
    if (has_dest_entity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dest_entity());
    }
    
    // optional string call_purpose = 13;
    if (has_call_purpose()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->call_purpose());
    }
    
    // optional bytes access_token = 14;
    if (has_access_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->access_token());
    }
    
    // optional bytes reserved = 15;
    if (has_reserved()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->reserved());
    }
    
    // optional string client_ip = 20;
    if (has_client_ip()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->client_ip());
    }
    
    // optional string target_ip = 30;
    if (has_target_ip()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->target_ip());
    }
    
    // optional uint32 target_port = 40;
    if (has_target_port()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_port());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Head::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Head* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Head*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Head::MergeFrom(const Head& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_magic_flag()) {
      set_magic_flag(from.magic_flag());
    }
    if (from.has_random_num()) {
      set_random_num(from.random_num());
    }
    if (from.has_flow_no()) {
      set_flow_no(from.flow_no());
    }
    if (from.has_session_no()) {
      set_session_no(from.session_no());
    }
    if (from.has_message_type()) {
      set_message_type(from.message_type());
    }
    if (from.has_worker_index()) {
      set_worker_index(from.worker_index());
    }
    if (from.has_tint_flag()) {
      set_tint_flag(from.tint_flag());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_source_entity()) {
      set_source_entity(from.source_entity());
    }
    if (from.has_dest_entity()) {
      set_dest_entity(from.dest_entity());
    }
    if (from.has_call_purpose()) {
      set_call_purpose(from.call_purpose());
    }
    if (from.has_access_token()) {
      set_access_token(from.access_token());
    }
    if (from.has_reserved()) {
      set_reserved(from.reserved());
    }
    if (from.has_client_ip()) {
      set_client_ip(from.client_ip());
    }
    if (from.has_target_ip()) {
      set_target_ip(from.target_ip());
    }
    if (from.has_target_port()) {
      set_target_port(from.target_port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Head::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Head::CopyFrom(const Head& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Head::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000017f) != 0x0000017f) return false;
  
  return true;
}

void Head::Swap(Head* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(magic_flag_, other->magic_flag_);
    std::swap(random_num_, other->random_num_);
    std::swap(flow_no_, other->flow_no_);
    std::swap(session_no_, other->session_no_);
    std::swap(message_type_, other->message_type_);
    std::swap(worker_index_, other->worker_index_);
    std::swap(tint_flag_, other->tint_flag_);
    std::swap(source_entity_, other->source_entity_);
    std::swap(dest_entity_, other->dest_entity_);
    std::swap(call_purpose_, other->call_purpose_);
    std::swap(access_token_, other->access_token_);
    std::swap(reserved_, other->reserved_);
    std::swap(client_ip_, other->client_ip_);
    std::swap(target_ip_, other->target_ip_);
    std::swap(target_port_, other->target_port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Head::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Head_descriptor_;
  metadata.reflection = Head_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Body::kSimpleResponseFieldNumber;
const int Body::kHeartBeatRequestFieldNumber;
const int Body::kHeartBeatResponseFieldNumber;
#endif  // !_MSC_VER

Body::Body()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Body::InitAsDefaultInstance() {
  simple_response_ = const_cast< ::ucloud::SimpleResponse*>(&::ucloud::SimpleResponse::default_instance());
  heart_beat_request_ = const_cast< ::ucloud::HeartBeatRequest*>(&::ucloud::HeartBeatRequest::default_instance());
  heart_beat_response_ = const_cast< ::ucloud::HeartBeatResponse*>(&::ucloud::HeartBeatResponse::default_instance());
}

Body::Body(const Body& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Body::SharedCtor() {
  _cached_size_ = 0;
  simple_response_ = NULL;
  heart_beat_request_ = NULL;
  heart_beat_response_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Body::~Body() {
  SharedDtor();
}

void Body::SharedDtor() {
  if (this != default_instance_) {
    delete simple_response_;
    delete heart_beat_request_;
    delete heart_beat_response_;
  }
}

void Body::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Body::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Body_descriptor_;
}

const Body& Body::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ucloud_2eproto();  return *default_instance_;
}

Body* Body::default_instance_ = NULL;

Body* Body::New() const {
  return new Body;
}

void Body::Clear() {
  _extensions_.Clear();
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_simple_response()) {
      if (simple_response_ != NULL) simple_response_->::ucloud::SimpleResponse::Clear();
    }
    if (has_heart_beat_request()) {
      if (heart_beat_request_ != NULL) heart_beat_request_->::ucloud::HeartBeatRequest::Clear();
    }
    if (has_heart_beat_response()) {
      if (heart_beat_response_ != NULL) heart_beat_response_->::ucloud::HeartBeatResponse::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Body::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ucloud.SimpleResponse simple_response = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_simple_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_heart_beat_request;
        break;
      }
      
      // optional .ucloud.HeartBeatRequest heart_beat_request = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_heart_beat_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_heart_beat_request()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_heart_beat_response;
        break;
      }
      
      // optional .ucloud.HeartBeatResponse heart_beat_response = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_heart_beat_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_heart_beat_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        if ((800u <= tag)) {
          DO_(_extensions_.ParseField(tag, input, default_instance_,
                                      mutable_unknown_fields()));
          continue;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Body::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ucloud.SimpleResponse simple_response = 1;
  if (has_simple_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->simple_response(), output);
  }
  
  // optional .ucloud.HeartBeatRequest heart_beat_request = 3;
  if (has_heart_beat_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->heart_beat_request(), output);
  }
  
  // optional .ucloud.HeartBeatResponse heart_beat_response = 5;
  if (has_heart_beat_response()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->heart_beat_response(), output);
  }
  
  // Extension range [100, 536870912)
  _extensions_.SerializeWithCachedSizes(
      100, 536870912, output);
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Body::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .ucloud.SimpleResponse simple_response = 1;
  if (has_simple_response()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->simple_response(), target);
  }
  
  // optional .ucloud.HeartBeatRequest heart_beat_request = 3;
  if (has_heart_beat_request()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->heart_beat_request(), target);
  }
  
  // optional .ucloud.HeartBeatResponse heart_beat_response = 5;
  if (has_heart_beat_response()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->heart_beat_response(), target);
  }
  
  // Extension range [100, 536870912)
  target = _extensions_.SerializeWithCachedSizesToArray(
      100, 536870912, target);
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Body::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ucloud.SimpleResponse simple_response = 1;
    if (has_simple_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->simple_response());
    }
    
    // optional .ucloud.HeartBeatRequest heart_beat_request = 3;
    if (has_heart_beat_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->heart_beat_request());
    }
    
    // optional .ucloud.HeartBeatResponse heart_beat_response = 5;
    if (has_heart_beat_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->heart_beat_response());
    }
    
  }
  total_size += _extensions_.ByteSize();
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Body::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Body* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Body*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Body::MergeFrom(const Body& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_simple_response()) {
      mutable_simple_response()->::ucloud::SimpleResponse::MergeFrom(from.simple_response());
    }
    if (from.has_heart_beat_request()) {
      mutable_heart_beat_request()->::ucloud::HeartBeatRequest::MergeFrom(from.heart_beat_request());
    }
    if (from.has_heart_beat_response()) {
      mutable_heart_beat_response()->::ucloud::HeartBeatResponse::MergeFrom(from.heart_beat_response());
    }
  }
  _extensions_.MergeFrom(from._extensions_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Body::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Body::CopyFrom(const Body& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Body::IsInitialized() const {
  
  if (has_simple_response()) {
    if (!this->simple_response().IsInitialized()) return false;
  }
  if (has_heart_beat_response()) {
    if (!this->heart_beat_response().IsInitialized()) return false;
  }
  
  if (!_extensions_.IsInitialized()) return false;  return true;
}

void Body::Swap(Body* other) {
  if (other != this) {
    std::swap(simple_response_, other->simple_response_);
    std::swap(heart_beat_request_, other->heart_beat_request_);
    std::swap(heart_beat_response_, other->heart_beat_response_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
    _extensions_.Swap(&other->_extensions_);
  }
}

::google::protobuf::Metadata Body::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Body_descriptor_;
  metadata.reflection = Body_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int IpPortPair::kIpFieldNumber;
const int IpPortPair::kPortFieldNumber;
#endif  // !_MSC_VER

IpPortPair::IpPortPair()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void IpPortPair::InitAsDefaultInstance() {
}

IpPortPair::IpPortPair(const IpPortPair& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void IpPortPair::SharedCtor() {
  _cached_size_ = 0;
  ip_ = 0u;
  port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IpPortPair::~IpPortPair() {
  SharedDtor();
}

void IpPortPair::SharedDtor() {
  if (this != default_instance_) {
  }
}

void IpPortPair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IpPortPair::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IpPortPair_descriptor_;
}

const IpPortPair& IpPortPair::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ucloud_2eproto();  return *default_instance_;
}

IpPortPair* IpPortPair::default_instance_ = NULL;

IpPortPair* IpPortPair::New() const {
  return new IpPortPair;
}

void IpPortPair::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ip_ = 0u;
    port_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IpPortPair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 ip = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ip_)));
          set_has_ip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }
      
      // required uint32 port = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IpPortPair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ip(), output);
  }
  
  // required uint32 port = 2;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->port(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* IpPortPair::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 ip = 1;
  if (has_ip()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->ip(), target);
  }
  
  // required uint32 port = 2;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->port(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int IpPortPair::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 ip = 1;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ip());
    }
    
    // required uint32 port = 2;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IpPortPair::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IpPortPair* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IpPortPair*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IpPortPair::MergeFrom(const IpPortPair& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IpPortPair::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IpPortPair::CopyFrom(const IpPortPair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpPortPair::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void IpPortPair::Swap(IpPortPair* other) {
  if (other != this) {
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IpPortPair::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IpPortPair_descriptor_;
  metadata.reflection = IpPortPair_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseCode::kRetcodeFieldNumber;
const int ResponseCode::kErrorMessageFieldNumber;
#endif  // !_MSC_VER

ResponseCode::ResponseCode()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResponseCode::InitAsDefaultInstance() {
}

ResponseCode::ResponseCode(const ResponseCode& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseCode::SharedCtor() {
  _cached_size_ = 0;
  retcode_ = 0;
  error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseCode::~ResponseCode() {
  SharedDtor();
}

void ResponseCode::SharedDtor() {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    delete error_message_;
  }
  if (this != default_instance_) {
  }
}

void ResponseCode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResponseCode::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResponseCode_descriptor_;
}

const ResponseCode& ResponseCode::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ucloud_2eproto();  return *default_instance_;
}

ResponseCode* ResponseCode::default_instance_ = NULL;

ResponseCode* ResponseCode::New() const {
  return new ResponseCode;
}

void ResponseCode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    retcode_ = 0;
    if (has_error_message()) {
      if (error_message_ != &::google::protobuf::internal::kEmptyString) {
        error_message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResponseCode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 retcode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &retcode_)));
          set_has_retcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_error_message;
        break;
      }
      
      // optional string error_message = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_error_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_error_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->error_message().data(), this->error_message().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseCode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 retcode = 1;
  if (has_retcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->retcode(), output);
  }
  
  // optional string error_message = 2;
  if (has_error_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->error_message().data(), this->error_message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->error_message(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResponseCode::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 retcode = 1;
  if (has_retcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->retcode(), target);
  }
  
  // optional string error_message = 2;
  if (has_error_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->error_message().data(), this->error_message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->error_message(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResponseCode::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 retcode = 1;
    if (has_retcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->retcode());
    }
    
    // optional string error_message = 2;
    if (has_error_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->error_message());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseCode::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResponseCode* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResponseCode*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResponseCode::MergeFrom(const ResponseCode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_retcode()) {
      set_retcode(from.retcode());
    }
    if (from.has_error_message()) {
      set_error_message(from.error_message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResponseCode::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResponseCode::CopyFrom(const ResponseCode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseCode::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void ResponseCode::Swap(ResponseCode* other) {
  if (other != this) {
    std::swap(retcode_, other->retcode_);
    std::swap(error_message_, other->error_message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResponseCode::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResponseCode_descriptor_;
  metadata.reflection = ResponseCode_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int IpAddress::kIpFieldNumber;
const int IpAddress::kTypeFieldNumber;
#endif  // !_MSC_VER

IpAddress::IpAddress()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void IpAddress::InitAsDefaultInstance() {
}

IpAddress::IpAddress(const IpAddress& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void IpAddress::SharedCtor() {
  _cached_size_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IpAddress::~IpAddress() {
  SharedDtor();
}

void IpAddress::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (this != default_instance_) {
  }
}

void IpAddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IpAddress::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IpAddress_descriptor_;
}

const IpAddress& IpAddress::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ucloud_2eproto();  return *default_instance_;
}

IpAddress* IpAddress::default_instance_ = NULL;

IpAddress* IpAddress::New() const {
  return new IpAddress;
}

void IpAddress::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    type_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IpAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string ip = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }
      
      // required uint32 type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IpAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->ip(), output);
  }
  
  // required uint32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* IpAddress::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->ip(), target);
  }
  
  // required uint32 type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->type(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int IpAddress::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string ip = 1;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }
    
    // required uint32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->type());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IpAddress::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IpAddress* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IpAddress*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IpAddress::MergeFrom(const IpAddress& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IpAddress::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IpAddress::CopyFrom(const IpAddress& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpAddress::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void IpAddress::Swap(IpAddress* other) {
  if (other != this) {
    std::swap(ip_, other->ip_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IpAddress::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IpAddress_descriptor_;
  metadata.reflection = IpAddress_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SimpleResponse::kRcFieldNumber;
#endif  // !_MSC_VER

SimpleResponse::SimpleResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SimpleResponse::InitAsDefaultInstance() {
  rc_ = const_cast< ::ucloud::ResponseCode*>(&::ucloud::ResponseCode::default_instance());
}

SimpleResponse::SimpleResponse(const SimpleResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SimpleResponse::SharedCtor() {
  _cached_size_ = 0;
  rc_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SimpleResponse::~SimpleResponse() {
  SharedDtor();
}

void SimpleResponse::SharedDtor() {
  if (this != default_instance_) {
    delete rc_;
  }
}

void SimpleResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SimpleResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SimpleResponse_descriptor_;
}

const SimpleResponse& SimpleResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ucloud_2eproto();  return *default_instance_;
}

SimpleResponse* SimpleResponse::default_instance_ = NULL;

SimpleResponse* SimpleResponse::New() const {
  return new SimpleResponse;
}

void SimpleResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_rc()) {
      if (rc_ != NULL) rc_->::ucloud::ResponseCode::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SimpleResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ucloud.ResponseCode rc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SimpleResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ucloud.ResponseCode rc = 1;
  if (has_rc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->rc(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SimpleResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ucloud.ResponseCode rc = 1;
  if (has_rc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->rc(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SimpleResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ucloud.ResponseCode rc = 1;
    if (has_rc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rc());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SimpleResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SimpleResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SimpleResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SimpleResponse::MergeFrom(const SimpleResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rc()) {
      mutable_rc()->::ucloud::ResponseCode::MergeFrom(from.rc());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SimpleResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SimpleResponse::CopyFrom(const SimpleResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimpleResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_rc()) {
    if (!this->rc().IsInitialized()) return false;
  }
  return true;
}

void SimpleResponse::Swap(SimpleResponse* other) {
  if (other != this) {
    std::swap(rc_, other->rc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SimpleResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SimpleResponse_descriptor_;
  metadata.reflection = SimpleResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HeartBeatRequest::kPayloadFieldNumber;
#endif  // !_MSC_VER

HeartBeatRequest::HeartBeatRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HeartBeatRequest::InitAsDefaultInstance() {
}

HeartBeatRequest::HeartBeatRequest(const HeartBeatRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HeartBeatRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeartBeatRequest::~HeartBeatRequest() {
  SharedDtor();
}

void HeartBeatRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HeartBeatRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HeartBeatRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HeartBeatRequest_descriptor_;
}

const HeartBeatRequest& HeartBeatRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ucloud_2eproto();  return *default_instance_;
}

HeartBeatRequest* HeartBeatRequest::default_instance_ = NULL;

HeartBeatRequest* HeartBeatRequest::New() const {
  return new HeartBeatRequest;
}

void HeartBeatRequest::Clear() {
  payload_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HeartBeatRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes payload = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_payload;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HeartBeatRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated bytes payload = 1;
  for (int i = 0; i < this->payload_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->payload(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HeartBeatRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated bytes payload = 1;
  for (int i = 0; i < this->payload_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(1, this->payload(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HeartBeatRequest::ByteSize() const {
  int total_size = 0;
  
  // repeated bytes payload = 1;
  total_size += 1 * this->payload_size();
  for (int i = 0; i < this->payload_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->payload(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartBeatRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HeartBeatRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HeartBeatRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HeartBeatRequest::MergeFrom(const HeartBeatRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  payload_.MergeFrom(from.payload_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HeartBeatRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeartBeatRequest::CopyFrom(const HeartBeatRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartBeatRequest::IsInitialized() const {
  
  return true;
}

void HeartBeatRequest::Swap(HeartBeatRequest* other) {
  if (other != this) {
    payload_.Swap(&other->payload_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HeartBeatRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HeartBeatRequest_descriptor_;
  metadata.reflection = HeartBeatRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HeartBeatResponse::kRcFieldNumber;
const int HeartBeatResponse::kPayloadFieldNumber;
#endif  // !_MSC_VER

HeartBeatResponse::HeartBeatResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HeartBeatResponse::InitAsDefaultInstance() {
  rc_ = const_cast< ::ucloud::ResponseCode*>(&::ucloud::ResponseCode::default_instance());
}

HeartBeatResponse::HeartBeatResponse(const HeartBeatResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HeartBeatResponse::SharedCtor() {
  _cached_size_ = 0;
  rc_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeartBeatResponse::~HeartBeatResponse() {
  SharedDtor();
}

void HeartBeatResponse::SharedDtor() {
  if (this != default_instance_) {
    delete rc_;
  }
}

void HeartBeatResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HeartBeatResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HeartBeatResponse_descriptor_;
}

const HeartBeatResponse& HeartBeatResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ucloud_2eproto();  return *default_instance_;
}

HeartBeatResponse* HeartBeatResponse::default_instance_ = NULL;

HeartBeatResponse* HeartBeatResponse::New() const {
  return new HeartBeatResponse;
}

void HeartBeatResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_rc()) {
      if (rc_ != NULL) rc_->::ucloud::ResponseCode::Clear();
    }
  }
  payload_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HeartBeatResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .ucloud.ResponseCode rc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_payload;
        break;
      }
      
      // repeated bytes payload = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_payload;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HeartBeatResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .ucloud.ResponseCode rc = 1;
  if (has_rc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->rc(), output);
  }
  
  // repeated bytes payload = 2;
  for (int i = 0; i < this->payload_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->payload(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HeartBeatResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .ucloud.ResponseCode rc = 1;
  if (has_rc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->rc(), target);
  }
  
  // repeated bytes payload = 2;
  for (int i = 0; i < this->payload_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(2, this->payload(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HeartBeatResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .ucloud.ResponseCode rc = 1;
    if (has_rc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rc());
    }
    
  }
  // repeated bytes payload = 2;
  total_size += 1 * this->payload_size();
  for (int i = 0; i < this->payload_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->payload(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartBeatResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HeartBeatResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HeartBeatResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HeartBeatResponse::MergeFrom(const HeartBeatResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  payload_.MergeFrom(from.payload_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rc()) {
      mutable_rc()->::ucloud::ResponseCode::MergeFrom(from.rc());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HeartBeatResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeartBeatResponse::CopyFrom(const HeartBeatResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartBeatResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_rc()) {
    if (!this->rc().IsInitialized()) return false;
  }
  return true;
}

void HeartBeatResponse::Swap(HeartBeatResponse* other) {
  if (other != this) {
    std::swap(rc_, other->rc_);
    payload_.Swap(&other->payload_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HeartBeatResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HeartBeatResponse_descriptor_;
  metadata.reflection = HeartBeatResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InternalHead::kFdFieldNumber;
const int InternalHead::kPeerAddrFieldNumber;
const int InternalHead::kPeerPortFieldNumber;
const int InternalHead::kSockAddrFieldNumber;
const int InternalHead::kSockPortFieldNumber;
#endif  // !_MSC_VER

InternalHead::InternalHead()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void InternalHead::InitAsDefaultInstance() {
}

InternalHead::InternalHead(const InternalHead& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void InternalHead::SharedCtor() {
  _cached_size_ = 0;
  fd_ = 0;
  peer_addr_ = 0u;
  peer_port_ = 0;
  sock_addr_ = 0u;
  sock_port_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InternalHead::~InternalHead() {
  SharedDtor();
}

void InternalHead::SharedDtor() {
  if (this != default_instance_) {
  }
}

void InternalHead::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InternalHead::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InternalHead_descriptor_;
}

const InternalHead& InternalHead::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ucloud_2eproto();  return *default_instance_;
}

InternalHead* InternalHead::default_instance_ = NULL;

InternalHead* InternalHead::New() const {
  return new InternalHead;
}

void InternalHead::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    fd_ = 0;
    peer_addr_ = 0u;
    peer_port_ = 0;
    sock_addr_ = 0u;
    sock_port_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InternalHead::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 fd = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fd_)));
          set_has_fd();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(160)) goto parse_peer_addr;
        break;
      }
      
      // required uint32 peer_addr = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_peer_addr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &peer_addr_)));
          set_has_peer_addr();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(240)) goto parse_peer_port;
        break;
      }
      
      // required int32 peer_port = 30;
      case 30: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_peer_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &peer_port_)));
          set_has_peer_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(320)) goto parse_sock_addr;
        break;
      }
      
      // required uint32 sock_addr = 40;
      case 40: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sock_addr:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sock_addr_)));
          set_has_sock_addr();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(400)) goto parse_sock_port;
        break;
      }
      
      // required int32 sock_port = 50;
      case 50: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sock_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sock_port_)));
          set_has_sock_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void InternalHead::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 fd = 10;
  if (has_fd()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->fd(), output);
  }
  
  // required uint32 peer_addr = 20;
  if (has_peer_addr()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(20, this->peer_addr(), output);
  }
  
  // required int32 peer_port = 30;
  if (has_peer_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(30, this->peer_port(), output);
  }
  
  // required uint32 sock_addr = 40;
  if (has_sock_addr()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(40, this->sock_addr(), output);
  }
  
  // required int32 sock_port = 50;
  if (has_sock_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(50, this->sock_port(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* InternalHead::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 fd = 10;
  if (has_fd()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->fd(), target);
  }
  
  // required uint32 peer_addr = 20;
  if (has_peer_addr()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(20, this->peer_addr(), target);
  }
  
  // required int32 peer_port = 30;
  if (has_peer_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(30, this->peer_port(), target);
  }
  
  // required uint32 sock_addr = 40;
  if (has_sock_addr()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(40, this->sock_addr(), target);
  }
  
  // required int32 sock_port = 50;
  if (has_sock_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(50, this->sock_port(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int InternalHead::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 fd = 10;
    if (has_fd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fd());
    }
    
    // required uint32 peer_addr = 20;
    if (has_peer_addr()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->peer_addr());
    }
    
    // required int32 peer_port = 30;
    if (has_peer_port()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->peer_port());
    }
    
    // required uint32 sock_addr = 40;
    if (has_sock_addr()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sock_addr());
    }
    
    // required int32 sock_port = 50;
    if (has_sock_port()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sock_port());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InternalHead::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InternalHead* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InternalHead*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InternalHead::MergeFrom(const InternalHead& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fd()) {
      set_fd(from.fd());
    }
    if (from.has_peer_addr()) {
      set_peer_addr(from.peer_addr());
    }
    if (from.has_peer_port()) {
      set_peer_port(from.peer_port());
    }
    if (from.has_sock_addr()) {
      set_sock_addr(from.sock_addr());
    }
    if (from.has_sock_port()) {
      set_sock_port(from.sock_port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InternalHead::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InternalHead::CopyFrom(const InternalHead& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InternalHead::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  return true;
}

void InternalHead::Swap(InternalHead* other) {
  if (other != this) {
    std::swap(fd_, other->fd_);
    std::swap(peer_addr_, other->peer_addr_);
    std::swap(peer_port_, other->peer_port_);
    std::swap(sock_addr_, other->sock_addr_);
    std::swap(sock_port_, other->sock_port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InternalHead::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InternalHead_descriptor_;
  metadata.reflection = InternalHead_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ucloud

// @@protoc_insertion_point(global_scope)
